== Kotlin

https://kotlinlang.org/[Kotlin] is an alternative language for the JVM.
Its compact syntax and native support for annotation processing make it a good fit for the mapper.

We have a full example at https://github.com/DataStax-Examples/object-mapper-jvm/tree/master/kotlin[DataStax-Examples/object-mapper-jvm/kotlin].

=== Writing the model

You can use Kotlin https://kotlinlang.org/docs/reference/data-classes.html[data classes] for your entities.
Data classes are usually link:../../entities/#mutability[immutable], but you don't need to declare that explicitly with https://docs.datastax.com/en/drivers/java/4.14/com/datastax/oss/driver/api/mapper/annotations/PropertyStrategy.html[@PropertyStrategy]: the mapper detects that it's processing Kotlin code, and will assume `mutable = false` by default:

[,kotlin]
----
@Entity
data class Product(@PartitionKey val id: Int?, val description: String?)
----

Data classes may also be made mutable (by declaring the components with `var` instead of `val`).
If you choose that approach, you'll have to annotate your entities with https://docs.datastax.com/en/drivers/java/4.14/com/datastax/oss/driver/api/mapper/annotations/PropertyStrategy.html[@PropertyStrategy], and also declare a default value for every component in order to generate a no-arg constructor:

[,kotlin]
----
@Entity
@PropertyStrategy(mutable = true)
data class Product(@PartitionKey var id: Int? = null, var description: String? = null)
----

All of the link:../../entities/#property-annotations[property annotations] can be declared directly on the components.

If you want to take advantage of link:../../daos/null_saving/[null saving strategies], your components should be nullable.

The other mapper interfaces are direct translations of the Java versions:

[,kotlin]
----
@Dao
interface ProductDao {
  @Insert
  fun insert(product: Product)
}
----

Known limitation: because of a Kotlin bug (https://youtrack.jetbrains.com/issue/KT-4779[KT-4779]), you can't use default interface methods.
They will appear as abstract methods to the mapper processor, which will generate an error since they are not properly annotated.
As a workaround, you can use a companion object method that takes the DAO as an argument (as shown in https://github.com/DataStax-Examples/object-mapper-jvm/blob/master/kotlin/src/main/kotlin/com/datastax/examples/mapper/killrvideo/user/UserDao.kt[UserDao.kt]), or query provider methods.

=== Building

==== Gradle

See the example's https://github.com/DataStax-Examples/object-mapper-jvm/blob/master/kotlin/build.gradle[build.gradle].

You enable Kotlin support with https://kotlinlang.org/docs/reference/using-gradle.html[kotlin] and https://kotlinlang.org/docs/reference/kapt.html#using-in-gradle[kotlin_kapt], and declare the mapper processor with the `kapt` directive.

==== Maven

Configure https://kotlinlang.org/docs/reference/using-maven.html#compiling-kotlin-and-java-sources[dual compilation] of Kotlin and Java sources.
In addition, you'll need an additional execution of the https://kotlinlang.org/docs/reference/kapt.html#using-in-maven[kotlin-maven-plugin:kapt] goal with the mapper processor before compilation:

[,xml]
----
<plugin>
  <groupId>org.jetbrains.kotlin</groupId>
  <artifactId>kotlin-maven-plugin</artifactId>
  <version>${kotlin.version}</version>
  <executions>
    <execution>
      <id>kapt</id>
      <goals><goal>kapt</goal></goals>
      <configuration>
        <sourceDirs>
          <sourceDir>src/main/kotlin</sourceDir>
          <sourceDir>src/main/java</sourceDir>
        </sourceDirs>
        <annotationProcessorPaths>
          <annotationProcessorPath>
            <groupId>com.datastax.oss</groupId>
            <artifactId>java-driver-mapper-processor</artifactId>
            <version>${java-driver.version}</version>
          </annotationProcessorPath>
        </annotationProcessorPaths>
      </configuration>
    </execution>
    <execution>
      <id>compile</id>
      <goals><goal>compile</goal></goals>
      ...
    </execution>
  </executions>
</plugin>
----
